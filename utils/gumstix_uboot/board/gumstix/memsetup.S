#include <config.h>
#include <version.h>
#include <asm/arch/pxa-regs.h>


.macro CPWAIT
	mrc	 p15,0,r0,c2,c0,0
	mov	 r0,r0
	sub	 pc,pc,#4
.endm


.globl lowlevel_init
lowlevel_init:


	cmp	pc, #0xa0000000			/** test if we're in SDRAM		**/
	bhi	end_of_memsetup			/** if we are, then jump		**/

	/* First, setup GPIOs */

	ldr		r0,	=GPSR0
	ldr		r1,	=CFG_GPSR0_VAL
	str		r1,   [r0]

	ldr		r0,	=GPSR1
	ldr		r1,	=CFG_GPSR1_VAL
	str		r1,   [r0]

	ldr		r0,	=GPSR2
	ldr		r1,	=CFG_GPSR2_VAL
	str		r1,   [r0]

	ldr		r0,	=GPCR0
	ldr		r1,	=CFG_GPCR0_VAL
	str		r1,   [r0]

	ldr		r0,	=GPCR1
	ldr		r1,	=CFG_GPCR1_VAL
	str		r1,   [r0]

	ldr		r0,	=GPCR2
	ldr		r1,	=CFG_GPCR2_VAL
	str		r1,   [r0]

	ldr		r0,	=GPDR0
	ldr		r1,	=CFG_GPDR0_VAL
	str		r1,   [r0]

	ldr		r0,	=GPDR1
	ldr		r1,	=CFG_GPDR1_VAL
	str		r1,   [r0]

	ldr		r0,	=GPDR2
	ldr		r1,	=CFG_GPDR2_VAL
	str		r1,   [r0]

	ldr		r0,	=GAFR0_L
	ldr		r1,	=CFG_GAFR0_L_VAL
	str		r1,   [r0]

	ldr		r0,	=GAFR0_U
	ldr		r1,	=CFG_GAFR0_U_VAL
	str		r1,   [r0]

	ldr		r0,	=GAFR1_L
	ldr		r1,	=CFG_GAFR1_L_VAL
	str		r1,   [r0]

	ldr		r0,	=GAFR1_U
	ldr		r1,	=CFG_GAFR1_U_VAL
	str		r1,   [r0]

	ldr		r0,	=GAFR2_L
	ldr		r1,	=CFG_GAFR2_L_VAL
	str		r1,   [r0]

	ldr		r0,	=GAFR2_U
	ldr		r1,	=CFG_GAFR2_U_VAL
	str		r1,   [r0]

	ldr		r0,	=PSSR
	ldr		r1,	=CFG_PSSR_VAL
	str		r1,	[r0]
		
	
	/* The procedure below uses sample code generated by the Intel PXA250 Memory
	 * Configuration Tool [http://appzone.intel.com/pcg/pxa250/memory/] which has
	 * then been modified manually while following the documentation in
	 * "Intel PXA255 Process Developer's Manual" [order #278693-002] 
	 * Chapter 6.11 - Hardware, Watchdog, or Sleep Reset Operation */

	/* Step 1: After hardware reset, complete a power-on wait of 200us to allow clocks to stabilize */

	ldr	r3, =OSCR		/* reset the OS Timer Count to zero */
	mov	r2, #0
	str	r2, [r3]
	ldr	r4, =0x300		/* really 0x2E1 is about 200usec, so 0x300 should be plenty */
10:
	ldr	r2, [r3]
	cmp	r4, r2
	bgt	10b

	/* Step 1a: Write MSC0, MSC1, MSC2 */
	ldr	r3, =MSC0		/* Configures /CS0 and /CS1 */
	ldr	r2, =0x128C26AB		/* Generated value */
	str	r2, [r3]
	ldr	r2, [r3]		/* the MSC register should be read after it is written with */
					/* a new value before an access to the memory is attempted. */
					/* (see MSC section of manual) */
	ldr	r3, =MSC1		/* /CS2 and /CS3 */
	ldr	r2, =0x0000128C		/* Generated value */
	str	r2, [r3]
	ldr	r2, [r3]

	/* Step 1b: Write MECR, MCMEM0, MCMEM1, MCATT0, MCATT1, MCIO0, MCIO1 (Skip on gumstix) */
	/* Step 1c: Write MDREFR:K0RUN and MDREFR:E0PIN. Configure MDREFR:K0DB2. Retain
	 *          the current values of MDREFR:APD and MDREFR:SLFRSH. MDREFR:DRI must
	 *          contain a valid value. Deassert MDREFR:KxFREE. (Skip on gumstix) */

	ldr	r3, =MDREFR
	ldr	r2, [r3]		/* read MDREFR value */

	ldr	r1, =0xfff
	bic	r2, r2, r1		/* Clear DRI -- INTEL TOOL LEAVES THIS STEP OUT!! */
	orr	r2, r2, #0x018		/* configure a valid SDRAM Refresh Interval (DRI) */
	str	r2, [r3]

	/* Step 2: Configure Synchronous Static memory (Skip on gumstix) */

	/* Step 4: In systems that contain SDRAM, transition the SDRAM controller through the following state sequence:
	 *         a. self-refresh
	 *         b. power-down
	 *         c. PWRDNX
	 *         d. NOP */

	orr	r2, r2, #0x00010000	/* assert K1RUN for SDCLK1 */
	bic	r2, r2, #0x000A4000	/* clear K0DB2, K1DB2 and K2DB2 */
	str	r2, [r3]		/* change from "self-refresh and clock-stop" to "self-refresh" state */

	bic	r2, r2, #0x00400000	/* clear SLFRSH bit field */
	str	r2, [r3]		/* change from "self-refresh" to "Power-down" state */

	orr	r2, r2, #0x00008000	/* set the E1PIN bit field */
	str	r2, [r3]		/* change from "Power-down" to "PWRDNX" state */

	nop	/* no action is required to change from "PWRDNX" to "NOP" state */

	/* Step 4f: Write MDCNFG (with enable bits deasserted), MDCNFG:DE3:2,1:0 set to 0. */

	ldr	r3, =MDCNFG		/* Load the SDRAM Configuration register. Must not be enabled yet. */
	ldr	r2, =0x000019C8		/* Value from Intel tool */
	str	r2, [r3]		/* Write to MDCNFG register */

	/* Step 5: For systems that contain SDRAM, wait a specified NOP power-up waiting period required by
	 * the SDRAMs to ensure the SDRAMs receive a stable clock with a NOP condition */

	ldr	r3, =OSCR		/* reset the OS Timer Count to zero */
	mov	r2, #0 
	str	r2, [r3] 
	ldr	r4, =0x300		/* really 0x2E1 is about 200usec, so 0x300 should be plenty */
20:
	ldr	r2, [r3] 
	cmp	r4, r2
	bgt	20b 

	/* Step 6: Ensure the data cache is disabled -- should not be needed out of reset, but best to be safe*/

	mov	r0, #0x78		/* turn everything off */
	mcr	p15, 0, r0, c1, c0, 0	/* caches off, MMU off, etc. */

	CPWAIT				/* wait for co-processor */

	/* Step 7: On a hardware reset in systems that contain SDRAM, trigger the specified number (typically
		eight) of refresh cycles by attempting non-burst read or write accesses to any disabled
		SDRAM bank. Each such access causes a simultaneous CBR refresh cycles for all four banks,
		which causes a pass through the CBR state and back to NOP. On the first pass, the PALL state
		occurs before the CBR state. */

	ldr	r3, =PHYS_SDRAM_1
	mov	r2, #9	/* now must do 9 (!) refresh or CBR commands before the first access */
CBR_refresh1:
	str	r2, [r3]
	subs	r2, r2, #1 
	bne	CBR_refresh1 

	/* Step 8: Can re-enable DCACHE if it was disabled above (Skip on gumstix) */

	/* Step 9: Enable SDRAM partitions */

	ldr	r3, =MDCNFG		/* sdram config -- sdram enable */
	ldr	r2, [r3] 
	orr	r2, r2, #0x00000001	/* enable partition 0 only */
	str	r2, [r3]		/* write to MDCNFG */

	/* Step 10: In systems containing SDRAM, write the MDMRS register to trigger an MRS command to all
	 * enabled banks of SDRAM. For each SDRAM partition pair that has one or both partitions
	 * enabled, this forces a pass through the MRS state and back to NOP. The CAS latency must be
	 * the only variable option and is derived from the value programmed in the
	 * MDCNFG:MDTC0,2 fields. The burst type is programmed to sequential and the length is set
	 * to four. */

	ldr	r3, =MDMRS		/* write the MDMRS */
	ldr	r2, =0x00020022		/* the writable bits will be written as a 0 */
	str	r2, [r3]

	/* Step 11: (optional) Enable auto-power-down */

	ldr	r3, =MDREFR		/* enable auto-power-down */
	ldr	r2, [r3] 
	orr	r2, r2, #0x00100000	/* set the APD bit */
	str	r2, [r3]		/* write to MDREFR */

	/* enable the 32Khz oscillator for RTC and PowerManager             */

	ldr     r1,  =OSCC
	mov     r2,  #OSCC_OON
	str     r2,  [r1]

	/* NOTE:  spin here until OSCC.OOK get set, meaning the PLL         */
	/* has settled.                                                     */
/*60:
	ldr     r2, [r1]
	ands    r2, r2, #1
	beq     60b							*/

end_of_memsetup:
	mov	pc, lr

